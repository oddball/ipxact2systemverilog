<?xml version="1.0" encoding="UTF-8"?>
<!--
// Description : memoryMap.xsd
// Author: The SPIRIT Consortium Schema Working Group
//
// Revision:    $Revision: 1540 $
// Date:        $Date: 2010-02-28 18:26:46 -0600 (Sun, 28 Feb 2010) $
//
// Copyright (c) 2005, 2006, 2007, 2008, 2009, 2010 The SPIRIT Consortium.
//
// This XML file is believed to be a consistent XML Schema expression for
// creating and validating XML documents based on the IEEE Std 1685-2009
// Standard for IP-XACT, Standard Structure for Packaging, Integrating
// and Re-using IP within Tool-flows. This is a file in the format
// specified by the World Wide Web Consortium (W3C) as XML Schema
// definition language.
//
// The purpose of this schema is to allow the creation and validation of
// XML documents conforming to the IEEE Std 1685-2009 Standard for
// IP-XACT, Standard Structure for Packaging, Integrating and Re-using IP
// within Tool-flows.
//
// USE AT YOUR OWN RISK.
//
// This source file is provided on an AS IS basis.  The SPIRIT
// Consortium disclaims any warranty express or implied including
// any warranty of merchantability and fitness for use for a
// particular purpose.
//
// The user of the source file shall indemnify and hold The SPIRIT
// Consortium and its members harmless from any damages or liability.
//
// This file may be copied, and distributed, WITHOUT
// modifications; this notice must be included on any copy.
//
// This schema shall not be modified, adapted, altered, sublicensed, nor
// any derivative works shall be created based upon the schema.  The
// intended and allowed uses of the schema include:
//
//  o Creating and validating XML documents that conform to the schema
//
//  o Building software programs and systems based on the schema
//
//  o Distributing verbatim copy of the schema as long as the full text
//  of this license is included in all copies of the schema.
//  Specifically, a tool may include full copies of the schema, and these
//  copies may be distributed by the tool provider directly.  A link or
//  URL to the original of the schema is inherent in the schema URI.
//
//  o Documents which are validated against this schema may also
//  reference additional schema. These additional schemas may provide for
//  validation of elements and attributes at the extension points
//  explicitly and implicitly included in the IEEE 1685-2009 standard.
//
//  o No right to create new schemas derived from parts of this base
//  schema is granted pursuant to this License.
//
// Users are requested to provide feedback to The SPIRIT Consortium
// using either mailto:feedback@lists.spiritconsortium.org or the forms at
// http://www.spiritconsortium.org/about/contact_us/
 -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5" targetNamespace="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5" elementFormDefault="qualified" attributeFormDefault="qualified">
    <xs:include schemaLocation="file.xsd"/>
    <xs:include schemaLocation="simpleTypes.xsd"/>
    <xs:simpleType name="accessType">
        <xs:annotation>
            <xs:documentation>The read/write accessability of an addess block.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token">
            <xs:enumeration value="read-only"/>
            <xs:enumeration value="write-only"/>
            <xs:enumeration value="read-write"/>
            <xs:enumeration value="writeOnce"/>
            <xs:enumeration value="read-writeOnce"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="bankAlignmentType">
        <xs:annotation>
            <xs:documentation>'serial' or 'parallel' bank alignment.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token">
            <xs:enumeration value="serial"/>
            <xs:enumeration value="parallel"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="usageType">
        <xs:annotation>
            <xs:documentation>Describes the usage of an address block.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:token">
            <xs:enumeration value="memory">
                <xs:annotation>
                    <xs:documentation>Denotes an address range that can be used for read-write or read-only data storage.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="register">
                <xs:annotation>
                    <xs:documentation>Denotes an address block that is used to communicate with hardware.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="reserved">
                <xs:annotation>
                    <xs:documentation>Denotes an address range that must remain unoccupied.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:attribute name="addressSpaceRef" type="xs:Name">
        <xs:annotation>
            <xs:documentation>A reference to a unique address space.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="memoryMapRef" type="xs:Name">
        <xs:annotation>
            <xs:documentation>A reference to a unique memory map.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bankAlignment" type="spirit:bankAlignmentType">
        <xs:annotation>
            <xs:documentation>Describes whether this bank's blocks are aligned in 'parallel' or 'serial'.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="masterRef" type="xs:Name">
        <xs:annotation>
            <xs:documentation>For subspaceMap elements, this attribute identifies the master that contains the address space to be mapped.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segmentRef" type="xs:Name">
        <xs:annotation>
            <xs:documentation>Refernce to a segment of the addressSpace of the masterRef attribute.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:complexType name="addressBankType">
        <xs:annotation>
            <xs:documentation>Top level bank the specify an address</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:addressSpecifier"/>
            <xs:group ref="spirit:bankBase"/>
        </xs:sequence>
        <xs:attribute ref="spirit:bankAlignment" use="required"/>
    </xs:complexType>
    <xs:complexType name="addressBlockType">
        <xs:annotation>
            <xs:documentation>Top level address block that specify an address</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:addressSpecifier"/>
            <xs:group ref="spirit:addressBlockDefinitionGroup"/>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="spirit:id"/>
    </xs:complexType>
    <xs:complexType name="addrSpaceRefType">
        <xs:annotation>
            <xs:documentation>Base type for an element which references an address space.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="spirit:addressSpaceRef" use="required"/>
    </xs:complexType>
    <xs:complexType name="memoryMapRefType">
        <xs:annotation>
            <xs:documentation>Base type for an element which references an memory map.  Reference is kept in an attribute rather than the text value, so that the type may be extended with child elements if necessary.</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="spirit:memoryMapRef" use="required"/>
    </xs:complexType>
    <xs:complexType name="bankedBankType">
        <xs:annotation>
            <xs:documentation>Banks nested inside a bank do not specify address.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:bankBase"/>
        </xs:sequence>
        <xs:attribute ref="spirit:bankAlignment" use="required"/>
    </xs:complexType>
    <xs:complexType name="bankedBlockType">
        <xs:annotation>
            <xs:documentation>Address blocks inside a bank do not specify address.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:blockSize"/>
            <xs:group ref="spirit:addressBlockExtensions"/>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="spirit:id"/>
    </xs:complexType>
    <xs:complexType name="bankedSubspaceType">
        <xs:annotation>
            <xs:documentation>Subspace references inside banks do not specify an address.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroupOptional"/>
            <xs:element ref="spirit:parameters" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Any parameters that may apply to the subspace reference.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="spirit:masterRef" use="required"/>
    </xs:complexType>
    <xs:complexType name="fieldType">
        <xs:annotation>
            <xs:documentation>A field within a register</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:element name="bitOffset" type="xs:nonNegativeInteger">
                <xs:annotation>
                    <xs:documentation>Offset of this field's bit 0 from bit 0 of the register.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:group ref="spirit:fieldDefinitionGroup"/>
            <xs:element ref="spirit:parameters" minOccurs="0"/>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="spirit:id"/>
    </xs:complexType>
    <xs:group name="memoryMap">
        <xs:annotation>
            <xs:documentation>A group elements for a memoryMap</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element ref="spirit:addressBlock"/>
            <xs:element ref="spirit:bank"/>
            <xs:element name="subspaceMap" type="spirit:subspaceRefType">
                <xs:annotation>
                    <xs:documentation>Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:choice>
    </xs:group>
    <xs:complexType name="memoryMapType">
        <xs:annotation>
            <xs:documentation>Map of address space blocks on slave slave bus interface.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:memoryMap" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="memoryRemap" type="spirit:memoryRemapType" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Additional memory map elements that are dependent on the component state.</xs:documentation>
                </xs:annotation>
                <xs:key name="MRMKey">
                    <xs:selector xpath="spirit:subspaceMap|spirit:addressBlock|spirit:bank"/>
                    <xs:field xpath="spirit:name"/>
                </xs:key>
            </xs:element>
            <xs:element ref="spirit:addressUnitBits" minOccurs="0"/>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="spirit:id"/>
    </xs:complexType>
    <xs:complexType name="memoryRemapType">
        <xs:annotation>
            <xs:documentation>Map of address space blocks on a slave bus interface in a specific remap state.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:memoryMap" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="state" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>State of the component in which the memory map is active.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="spirit:id"/>
    </xs:complexType>
    <xs:complexType name="localMemoryMapType">
        <xs:annotation>
            <xs:documentation>Map of address space blocks on the local memory map of a master bus interface.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:memoryMap" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute ref="spirit:id"/>
    </xs:complexType>
    <xs:complexType name="subspaceRefType">
        <xs:annotation>
            <xs:documentation>Address subspace type.  Its subspaceReference attribute references the subspace from which the dimensions are taken.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:annotation>
                <xs:documentation>Any parameters that may apply to the subspace reference.</xs:documentation>
            </xs:annotation>
            <xs:group ref="spirit:nameGroup"/>
            <xs:group ref="spirit:addressSpecifier"/>
            <xs:element ref="spirit:parameters" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Any parameters that may apply to the subspace reference.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute ref="spirit:masterRef" use="required"/>
        <xs:attribute ref="spirit:segmentRef"/>
    </xs:complexType>
    <xs:element name="volatile" type="xs:boolean" default="false">
        <xs:annotation>
            <xs:documentation>Indicates whether the data is volatile.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="access">
        <xs:annotation>
            <xs:documentation>Indicates the accessibility of the data in the address bank, address block, register or field.  Possible values are 'read-write', 'read-only',  'write-only', 'writeOnce' and 'read-writeOnce'. If not specified the value is inherited from the containing object.</xs:documentation>
        </xs:annotation>
        <xs:simpleType>
            <xs:restriction base="spirit:accessType"/>
        </xs:simpleType>
    </xs:element>
    <xs:element name="addressBlock" type="spirit:addressBlockType">
        <xs:annotation>
            <xs:documentation>This is a single contiguous block of memory inside a memory map.</xs:documentation>
        </xs:annotation>
        <xs:key name="registerAndRegisterFileAndABKey">
            <xs:selector xpath="spirit:register|spirit:registerFile|spirit:register/spirit:alternateRegisters/spirit:alternateRegister"/>
            <xs:field xpath="spirit:name"/>
        </xs:key>
    </xs:element>
    <xs:element name="addressSpaceRef" type="spirit:addrSpaceRefType">
        <xs:annotation>
            <xs:documentation>References the address space.  The name of the address space is kept in its addressSpaceRef attribute.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="addressSpaces">
        <xs:annotation>
            <xs:documentation>If this component is a bus master, this lists all the address spaces
defined by the component.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="addressSpace" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>This defines a logical space, referenced by a bus master.</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:sequence>
                            <xs:group ref="spirit:nameGroup"/>
                            <xs:group ref="spirit:blockSize"/>
                            <xs:element name="segments" minOccurs="0">
                                <xs:annotation>
                                    <xs:documentation>Address segments withing an addressSpace </xs:documentation>
                                </xs:annotation>
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element name="segment" maxOccurs="unbounded">
                                            <xs:annotation>
                                                <xs:documentation>Address segment withing an addressSpace </xs:documentation>
                                            </xs:annotation>
                                            <xs:complexType>
                                                <xs:sequence>
                                                    <xs:group ref="spirit:nameGroup"/>
                                                    <xs:element name="addressOffset">
                                                        <xs:annotation>
                                                            <xs:documentation>Address offset of the segment within the containing address space.</xs:documentation>
                                                        </xs:annotation>
                                                        <xs:complexType>
                                                            <xs:simpleContent>
                                                                <xs:extension base="spirit:scaledNonNegativeInteger">
                                                                    <xs:attributeGroup ref="spirit:long.prompt.att"/>
                                                                </xs:extension>
                                                            </xs:simpleContent>
                                                        </xs:complexType>
                                                    </xs:element>
                                                    <xs:element name="range">
                                                        <xs:annotation>
                                                            <xs:documentation>The address range of asegment.  Expressed as the number of addressable units accessible to the segment. 				</xs:documentation>
                                                        </xs:annotation>
                                                        <xs:complexType>
                                                            <xs:simpleContent>
                                                                <xs:extension base="spirit:scaledPositiveInteger">
                                                                    <xs:attributeGroup ref="spirit:long.prompt.att"/>
                                                                </xs:extension>
                                                            </xs:simpleContent>
                                                        </xs:complexType>
                                                    </xs:element>
                                                    <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
                                                </xs:sequence>
                                            </xs:complexType>
                                        </xs:element>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element ref="spirit:addressUnitBits" minOccurs="0"/>
                            <xs:element ref="spirit:executableImage" minOccurs="0" maxOccurs="unbounded"/>
                            <xs:element name="localMemoryMap" type="spirit:localMemoryMapType" minOccurs="0">
                                <xs:annotation>
                                    <xs:documentation>Provides the local memory map of an address space.  Blocks in this memory map are accessable to master interfaces on this component that reference this address space.   They are not accessable to any external master interface.</xs:documentation>
                                </xs:annotation>
                                <xs:key name="LMMKey">
                                    <xs:selector xpath="spirit:subspaceMap|spirit:addressBlock|spirit:bank"/>
                                    <xs:field xpath="spirit:name"/>
                                </xs:key>
                            </xs:element>
                            <xs:element ref="spirit:parameters" minOccurs="0">
                                <xs:annotation>
                                    <xs:documentation>Data specific to this address space.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
                        </xs:sequence>
                    </xs:complexType>
                    <xs:key name="segmentRefKey">
                        <xs:selector xpath="spirit:segments/spirit:segment"/>
                        <xs:field xpath="spirit:name"/>
                    </xs:key>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="memoryMapRef" type="spirit:memoryMapRefType">
        <xs:annotation>
            <xs:documentation>References the memory map. The name of the memory map is kept in its memoryMapRef attribute.</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:element name="memoryMaps">
        <xs:annotation>
            <xs:documentation>Lists all the slave memory maps defined by the component.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="memoryMap" type="spirit:memoryMapType" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>The set of address blocks a bus slave contributes to the bus' address space.</xs:documentation>
                    </xs:annotation>
                    <xs:key name="remapStateMMKey">
                        <xs:selector xpath="spirit:memoryRemap"/>
                        <xs:field xpath="@spirit:state"/>
                    </xs:key>
                    <xs:key name="MMKey">
                        <xs:selector xpath="spirit:subspaceMap|spirit:addressBlock|spirit:bank|spirit:memoryRemap"/>
                        <xs:field xpath="spirit:name"/>
                    </xs:key>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="bank" type="spirit:addressBankType">
        <xs:annotation>
            <xs:documentation>Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.</xs:documentation>
        </xs:annotation>
        <xs:key name="bankedMMKey">
            <xs:selector xpath="spirit:subspaceMap|spirit:addressBlock|spirit:bank"/>
            <xs:field xpath="spirit:name"/>
        </xs:key>
    </xs:element>
    <xs:element name="baseAddress">
        <xs:annotation>
            <xs:documentation>Base of an address block, bank, subspace map or address space. Expressed as the number of addressable units from the containing memoryMap or localMemoryMap.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="spirit:scaledNonNegativeInteger">
                    <xs:attributeGroup ref="spirit:long.att"/>
                    <xs:attribute ref="spirit:prompt" default="Base Address:"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>
    <xs:element name="addressUnitBits" type="xs:positiveInteger">
        <xs:annotation>
            <xs:documentation>The number of data bits in an addressable unit. The default is byte addressable (8 bits).</xs:documentation>
        </xs:annotation>
    </xs:element>
    <xs:group name="addressBlockExtensions">
        <xs:annotation>
            <xs:documentation>This is a group of optional elements commonly added to various types of address blocks in a memory map.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:group ref="spirit:memoryBlockData"/>
            <xs:group ref="spirit:registerData"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="addressSpecifier">
        <xs:annotation>
            <xs:documentation>This group of elements describes an absolute or relative address of an address block in a memory map.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="spirit:baseAddress"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="bankBase">
        <xs:annotation>
            <xs:documentation>This group of elements is common to top level banks and banked banks.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="addressBlock" type="spirit:bankedBlockType">
                    <xs:annotation>
                        <xs:documentation>An address block within the bank.  No address information is supplied.</xs:documentation>
                    </xs:annotation>
                    <xs:key name="bankedRegisterAndRegisterFileAndABKey">
                        <xs:selector xpath="spirit:register|spirit:registerFile|spirit:register/spirit:alternateRegisters/spirit:alternateRegister"/>
                        <xs:field xpath="spirit:name"/>
                    </xs:key>
                </xs:element>
                <xs:element name="bank" type="spirit:bankedBankType">
                    <xs:annotation>
                        <xs:documentation>A nested bank of blocks within a bank.  No address information is supplied.</xs:documentation>
                    </xs:annotation>
                    <xs:key name="banked2MMKey">
                        <xs:selector xpath="spirit:subspaceMap|spirit:addressBlock|spirit:bank"/>
                        <xs:field xpath="spirit:name"/>
                    </xs:key>
                </xs:element>
                <xs:element name="subspaceMap" type="spirit:bankedSubspaceType">
                    <xs:annotation>
                        <xs:documentation>A subspace map within the bank.  No address information is supplied.</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
            <xs:group ref="spirit:memoryBlockData"/>
            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="blockSize">
        <xs:annotation>
            <xs:documentation>This group of elements describes the number of addressable units and the width of a row of an address block in a memory map.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="range">
                <xs:annotation>
                    <xs:documentation>The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
					number_of_bits_in_block = spirit:addressUnitBits * spirit:range
					number_of_rows_in_block = number_of_bits_in_block / spirit:width
					</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="spirit:scaledPositiveInteger">
                            <xs:attributeGroup ref="spirit:long.prompt.att"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element name="width">
                <xs:annotation>
                    <xs:documentation>The bit width of a row in the address block. The range and the width are related by the following formulas:
					number_of_bits_in_block = spirit:addressUnitBits * spirit:range
					number_of_rows_in_block = number_of_bits_in_block / spirit:width
					</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:nonNegativeInteger">
                            <xs:attributeGroup ref="spirit:long.prompt.att"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="memoryBlockData">
        <xs:annotation>
            <xs:documentation>This group of optional elements can be used to provide additional descriptions to an address block or bank.

Note that this is a group, not an element.  It does not appear in the XML, but its contents may.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="usage" type="spirit:usageType" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="spirit:volatile" minOccurs="0"/>
            <xs:element ref="spirit:access" minOccurs="0"/>
            <xs:element ref="spirit:parameters" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Any additional parameters needed to describe this address block to the generators.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="registerData">
        <xs:annotation>
            <xs:documentation>This group of optional elements describes the memory mapped registers of an address block</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="register" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>A single register</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:group ref="spirit:nameGroup"/>
                        <xs:element name="dim" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:element name="addressOffset" type="spirit:scaledNonNegativeInteger">
                            <xs:annotation>
                                <xs:documentation>Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                        <xs:group ref="spirit:registerDefinitionGroup"/>
                        <xs:element name="alternateRegisters" minOccurs="0">
                            <xs:annotation>
                                <xs:documentation>Alternate definitions for the current register</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:sequence>
                                    <xs:element name="alternateRegister" maxOccurs="unbounded">
                                        <xs:annotation>
                                            <xs:documentation>Alternate definition for the current register</xs:documentation>
                                        </xs:annotation>
                                        <xs:complexType>
                                            <xs:sequence>
                                                <xs:group ref="spirit:nameGroup"/>
                                                <xs:element name="alternateGroups">
                                                    <xs:annotation>
                                                        <xs:documentation>Defines a list of grouping names that this register description belongs.</xs:documentation>
                                                    </xs:annotation>
                                                    <xs:complexType>
                                                        <xs:sequence>
                                                            <xs:element name="alternateGroup" type="xs:Name" maxOccurs="unbounded">
                                                                <xs:annotation>
                                                                    <xs:documentation>Defines a grouping name that this register description belongs.</xs:documentation>
                                                                </xs:annotation>
                                                            </xs:element>
                                                        </xs:sequence>
                                                    </xs:complexType>
                                                </xs:element>
                                                <xs:group ref="spirit:alternateRegisterDefinitionGroup"/>
                                                <xs:element ref="spirit:parameters" minOccurs="0"/>
                                                <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
                                            </xs:sequence>
                                            <xs:attribute ref="spirit:id"/>
                                        </xs:complexType>
                                        <xs:key name="alternateRegisterFileRegisterFieldKey">
                                            <xs:selector xpath="spirit:field"/>
                                            <xs:field xpath="spirit:name"/>
                                        </xs:key>
                                    </xs:element>
                                </xs:sequence>
                            </xs:complexType>
                            <xs:key name="alternateRegister">
                                <xs:selector xpath="spirit:alternateRegister/spirit:alternateGroups"/>
                                <xs:field xpath="spirit:alternateGroup"/>
                            </xs:key>
                        </xs:element>
                        <xs:element ref="spirit:parameters" minOccurs="0"/>
                        <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute ref="spirit:id"/>
                </xs:complexType>
                <xs:key name="registerFileRegisterFieldKey">
                    <xs:selector xpath="spirit:field"/>
                    <xs:field xpath="spirit:name"/>
                </xs:key>
            </xs:element>
            <xs:element ref="spirit:registerFile" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>A structure of registers and register files</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:element name="enumeratedValues">
        <xs:annotation>
            <xs:documentation>Enumerates specific values that can be assigned to the bit field.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="enumeratedValue" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>Enumerates specific values that can be assigned to the bit field. The name of this enumerated value. This may be used as a token in generating code.</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:sequence>
                            <xs:group ref="spirit:nameGroup"/>
                            <xs:element name="value" type="spirit:scaledInteger">
                                <xs:annotation>
                                    <xs:documentation>Enumerated bit field value.</xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
                        </xs:sequence>
                        <xs:attribute name="usage" default="read-write">
                            <xs:annotation>
                                <xs:documentation>Usage for the enumeration. 'read' for a software read access. 'write' for a software write access. 'read-write' for a software read or write access.</xs:documentation>
                            </xs:annotation>
                            <xs:simpleType>
                                <xs:restriction base="xs:string">
                                    <xs:enumeration value="read"/>
                                    <xs:enumeration value="write"/>
                                    <xs:enumeration value="read-write"/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:complexType>
        <xs:key name="enumKey">
            <xs:selector xpath="spirit:enumeratedValue"/>
            <xs:field xpath="spirit:name"/>
        </xs:key>
    </xs:element>
    <xs:complexType name="valueMaskConfigType">
        <xs:annotation>
            <xs:documentation>This type is used to specify a value and optional mask that are configurable</xs:documentation>
        </xs:annotation>
        <xs:sequence/>
    </xs:complexType>
    <xs:group name="fieldData">
        <xs:annotation>
            <xs:documentation>Additional field data</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="spirit:volatile" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Indicates whether the data is volatile. The presumed value is 'false' if not present.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="spirit:access" minOccurs="0"/>
            <xs:element ref="spirit:enumeratedValues" minOccurs="0"/>
            <xs:element name="modifiedWriteValue" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:Name">
                        <xs:enumeration value="oneToClear"/>
                        <xs:enumeration value="oneToSet"/>
                        <xs:enumeration value="oneToToggle"/>
                        <xs:enumeration value="zeroToClear"/>
                        <xs:enumeration value="zeroToSet"/>
                        <xs:enumeration value="zeroToToggle"/>
                        <xs:enumeration value="clear"/>
                        <xs:enumeration value="set"/>
                        <xs:enumeration value="modify"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="writeValueConstraint" type="spirit:writeValueConstraintType" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The legal values that may be written to a field. If not specified the legal values are not specified.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="readAction" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                    <xs:restriction base="xs:Name">
                        <xs:enumeration value="clear"/>
                        <xs:enumeration value="set"/>
                        <xs:enumeration value="modify"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:element>
            <xs:element name="testable" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Can the field be tested with an automated register test routine. The presumed value is true if not specified.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:boolean">
                            <xs:attribute name="testConstraint" default="unconstrained">
                                <xs:annotation>
                                    <xs:documentation>Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.</xs:documentation>
                                </xs:annotation>
                                <xs:simpleType>
                                    <xs:restriction base="xs:string">
                                        <xs:enumeration value="unconstrained"/>
                                        <xs:enumeration value="restore"/>
                                        <xs:enumeration value="writeAsRead"/>
                                        <xs:enumeration value="readOnly"/>
                                    </xs:restriction>
                                </xs:simpleType>
                            </xs:attribute>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:complexType name="writeValueConstraintType">
        <xs:annotation>
            <xs:documentation>A constraint on the values that can be written to this field. Absence of this element implies that any value that fits can be written to it.</xs:documentation>
        </xs:annotation>
        <xs:choice>
            <xs:element name="writeAsRead" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>writeAsRead indicates that only a value immediately read before a write is a legal value to be written.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="useEnumeratedValues" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation>useEnumeratedValues indicates that only write enumeration value shall be legal values to be written.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:sequence>
                <xs:element name="minimum">
                    <xs:annotation>
                        <xs:documentation>The minimum legal value that may be written to a field</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="spirit:scaledNonNegativeInteger">
                                <xs:attributeGroup ref="spirit:long.prompt.att"/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
                <xs:element name="maximum">
                    <xs:annotation>
                        <xs:documentation>The maximum legal value that may be written to a field</xs:documentation>
                    </xs:annotation>
                    <xs:complexType>
                        <xs:simpleContent>
                            <xs:extension base="spirit:scaledNonNegativeInteger">
                                <xs:attributeGroup ref="spirit:long.prompt.att"/>
                            </xs:extension>
                        </xs:simpleContent>
                    </xs:complexType>
                </xs:element>
            </xs:sequence>
        </xs:choice>
    </xs:complexType>
    <xs:element name="registerFile">
        <xs:annotation>
            <xs:documentation>A structure of registers and register files</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:group ref="spirit:nameGroup"/>
                <xs:element name="dim" type="xs:nonNegativeInteger" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation>Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="addressOffset" type="spirit:scaledNonNegativeInteger">
                    <xs:annotation>
                        <xs:documentation>Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:group ref="spirit:registerFileDefinitionGroup"/>
                <xs:element ref="spirit:parameters" minOccurs="0"/>
                <xs:element ref="spirit:vendorExtensions" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute ref="spirit:id"/>
        </xs:complexType>
        <xs:key name="registerAndRegisterFile1Key">
            <xs:selector xpath="spirit:register|spirit:registerFile|spirit:register/spirit:alternateRegisters/spirit:alternateRegister"/>
            <xs:field xpath="spirit:name"/>
        </xs:key>
    </xs:element>
    <xs:group name="fieldDefinitionGroup">
        <xs:annotation>
            <xs:documentation>Field definition specific information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="typeIdentifier" type="xs:Name" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="bitWidth">
                <xs:annotation>
                    <xs:documentation>Width of the field in bits.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:positiveInteger">
                            <xs:attributeGroup ref="spirit:long.prompt.att"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:group ref="spirit:fieldData"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="registerFileDefinitionGroup">
        <xs:annotation>
            <xs:documentation>Register file defnition specific information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="typeIdentifier" type="xs:Name" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Identifier name used to indicate that multiple registerFile elements contain the exact same information except for the elements in the registerFileInstanceGroup.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="range">
                <xs:annotation>
                    <xs:documentation>The range of a register file.  Expressed as the number of addressable units accessible to the block. Specified in units of addressUnitBits.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="spirit:scaledPositiveInteger">
                            <xs:attributeGroup ref="spirit:long.prompt.att"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:group ref="spirit:registerData"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="addressBlockDefinitionGroup">
        <xs:annotation>
            <xs:documentation>Address block definition specific information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="typeIdentifier" type="xs:Name" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Identifier name used to indicate that multiple addressBlock elements contain the exact same information except for the elements in the addressBlockInstanceGroup.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:group ref="spirit:blockSize"/>
            <xs:group ref="spirit:memoryBlockData"/>
            <xs:group ref="spirit:registerData"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="registerDefinitionGroup">
        <xs:annotation>
            <xs:documentation>Register definition specific information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="typeIdentifier" type="xs:Name" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="size">
                <xs:annotation>
                    <xs:documentation>Width of the register in bits.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:simpleContent>
                        <xs:extension base="xs:positiveInteger">
                            <xs:attributeGroup ref="spirit:long.prompt.att"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xs:element>
            <xs:element ref="spirit:volatile" minOccurs="0"/>
            <xs:element ref="spirit:access" minOccurs="0"/>
            <xs:element name="reset" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register value at reset.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="value">
                            <xs:annotation>
                                <xs:documentation>The value itself.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:simpleContent>
                                    <xs:extension base="spirit:scaledNonNegativeInteger">
                                        <xs:attributeGroup ref="spirit:long.prompt.att"/>
                                    </xs:extension>
                                </xs:simpleContent>
                            </xs:complexType>
                        </xs:element>
                        <xs:element name="mask" minOccurs="0">
                            <xs:annotation>
                                <xs:documentation>Mask to be anded with the value before comparing to the reset value.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:simpleContent>
                                    <xs:extension base="spirit:scaledNonNegativeInteger">
                                        <xs:attributeGroup ref="spirit:long.prompt.att"/>
                                    </xs:extension>
                                </xs:simpleContent>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="field" type="spirit:fieldType" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Describes individual bit fields within the register.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
    <xs:group name="alternateRegisterDefinitionGroup">
        <xs:annotation>
            <xs:documentation>Alternate register file defnition specific information</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="typeIdentifier" type="xs:Name" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the alternateRegisterDefinitionGroup.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element ref="spirit:volatile" minOccurs="0"/>
            <xs:element ref="spirit:access" minOccurs="0"/>
            <xs:element name="reset" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Register value at reset.</xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="value">
                            <xs:annotation>
                                <xs:documentation>The value itself.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:simpleContent>
                                    <xs:extension base="spirit:scaledNonNegativeInteger">
                                        <xs:attributeGroup ref="spirit:long.prompt.att"/>
                                    </xs:extension>
                                </xs:simpleContent>
                            </xs:complexType>
                        </xs:element>
                        <xs:element name="mask" minOccurs="0">
                            <xs:annotation>
                                <xs:documentation>Mask to be anded with the value before comparing to the reset value.</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:simpleContent>
                                    <xs:extension base="spirit:scaledNonNegativeInteger">
                                        <xs:attributeGroup ref="spirit:long.prompt.att"/>
                                    </xs:extension>
                                </xs:simpleContent>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="field" type="spirit:fieldType" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Describes individual bit fields within the register.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:group>
</xs:schema>
